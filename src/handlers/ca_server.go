/*
Copyright (C) BABEC. All rights reserved.

SPDX-License-Identifier: Apache-2.0
*/

package handlers

import (
	"encoding/base64"
	"encoding/pem"
	"fmt"

	"chainmaker.org/chainmaker-ca-backend/src/models/db"
	"chainmaker.org/chainmaker-ca-backend/src/services"
	"github.com/gin-gonic/gin"
)

//Certificates are generated by the CSR
func GenCertByCsr() gin.HandlerFunc {
	return func(c *gin.Context) {
		//we first get Id class data through the form, and then get CSR stream file through file upload
		orgId := c.PostForm("orgId")
		userId := c.PostForm("userId")
		userType := c.PostForm("userType")
		certUsage := c.PostForm("certUsage")
		if err := services.CheckParametersEmpty(orgId, userId, userType, certUsage); err != nil {
			InputMissingJSONResp(err.Error(), c)
			return
		}
		curUserType, curCertUsage, err := services.CheckParameters(orgId, userId, userType, certUsage)
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		//Read the uploaded file separately and read the CSR stream file
		uploadFile, err := c.FormFile("csr")
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		file, err := uploadFile.Open()
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		defer file.Close()
		csrBytes, err := services.ReadWithFile(file)
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		_, err = services.ParseCsr(csrBytes)
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		certContent, err := services.GenCertByCsr(&services.GenCertByCsrReq{
			OrgId:     orgId,
			UserId:    userId,
			UserType:  curUserType,
			CertUsage: curCertUsage,
			CsrBytes:  csrBytes,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}
		SuccessfulJSONResp("", certContent, c)
	}
}

//Generate certificate
func GenCert() gin.HandlerFunc {
	return func(c *gin.Context) {
		var genCertReq GenCertReq
		if err := c.ShouldBind(&genCertReq); err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		if err := services.CheckParametersEmpty(genCertReq.OrgId, genCertReq.UserId,
			genCertReq.UserType, genCertReq.CertUsage, genCertReq.PrivateKeyPwd,
			genCertReq.Country, genCertReq.Locality, genCertReq.Province); err != nil {
			InputMissingJSONResp(err.Error(), c)
			return
		}
		curUserType, curCertUsage, err := services.CheckParameters(genCertReq.OrgId, genCertReq.UserId, genCertReq.UserType, genCertReq.CertUsage)
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}

		certContentAndPrivateKey, err := services.GenCert(&services.GenCertReq{
			OrgId:         genCertReq.OrgId,
			UserId:        genCertReq.UserId,
			UserType:      curUserType,
			CertUsage:     curCertUsage,
			PrivateKeyPwd: genCertReq.PrivateKeyPwd,
			Country:       genCertReq.Country,
			Locality:      genCertReq.Locality,
			Province:      genCertReq.Province,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}
		SuccessfulJSONResp("", certContentAndPrivateKey, c)
	}
}

//Query certificate
func QueryCert() gin.HandlerFunc {
	return func(c *gin.Context) {
		var queryCertReq QueryCertReq
		if err := c.ShouldBind(&queryCertReq); err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		if err := services.CheckParametersEmpty(queryCertReq.OrgId, queryCertReq.UserId,
			queryCertReq.UserType, queryCertReq.CertUsage); err != nil {
			InputMissingJSONResp(err.Error(), c)
			return
		}
		curUserType, curCertUsage, err := services.CheckParameters(queryCertReq.OrgId, queryCertReq.UserId, queryCertReq.UserType, queryCertReq.CertUsage)
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		certInfos, err := services.QueryCert(&services.QueryCertReq{
			OrgId:     queryCertReq.OrgId,
			UserId:    queryCertReq.UserId,
			UserType:  curUserType,
			CertUsage: curCertUsage,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}
		SuccessfulJSONResp("", certInfos, c)
	}
}

//Query certificate by status
func QueryCertByStatus() gin.HandlerFunc {
	return func(c *gin.Context) {
		var queryCertByStatusReq QueryCertByStatusReq
		if err := c.ShouldBind(&queryCertByStatusReq); err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		if err := services.CheckParametersEmpty(queryCertByStatusReq.OrgId, queryCertByStatusReq.UserId,
			queryCertByStatusReq.UserType, queryCertByStatusReq.CertUsage); err != nil {
			InputMissingJSONResp(err.Error(), c)
			return
		}
		curUserType, curCertUsage, err := services.CheckParameters(queryCertByStatusReq.OrgId, queryCertByStatusReq.UserId, queryCertByStatusReq.UserType, queryCertByStatusReq.CertUsage)
		if err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		curCertStatus, ok := db.Name2CertStatusMap[queryCertByStatusReq.CertStatus]
		if !ok {
			err := fmt.Errorf("the Cert Status does not meet the requirements")
			InputErrorJSONResp(err.Error(), c)
			return
		}
		certInfosList, err := services.QueryCertByStatus(&services.QueryCertByStatusReq{
			OrgId:      queryCertByStatusReq.OrgId,
			UserId:     queryCertByStatusReq.UserId,
			UserType:   curUserType,
			CertUsage:  curCertUsage,
			CertStatus: curCertStatus,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}
		SuccessfulJSONResp("", certInfosList, c)
	}
}

//renew certificate
func RenewCert() gin.HandlerFunc {
	return func(c *gin.Context) {
		var renewCertReq RenewCertReq
		if err := c.ShouldBind(&renewCertReq); err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		if renewCertReq.CertSn == 0 {
			err := fmt.Errorf("input SN is illegal")
			InputErrorJSONResp(err.Error(), c)
			return
		}
		certContent, err := services.RenewCert(&services.RenewCertReq{
			CertSn: renewCertReq.CertSn,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}
		SuccessfulJSONResp("", certContent, c)
	}
}

//Revoke certificate
func RevokeCert() gin.HandlerFunc {
	return func(c *gin.Context) {
		var revokeCertReq RevokeCertReq
		if err := c.ShouldBind(&revokeCertReq); err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		if revokeCertReq.IssueCertSn == 0 || revokeCertReq.RevokedCertSn == 0 {
			err := fmt.Errorf("input issue sn or revoked sn is illegal")
			InputErrorJSONResp(err.Error(), c)
			return
		}
		crlBytes, err := services.RevokeCert(&services.RevokeCertReq{
			RevokedCertSn: revokeCertReq.RevokedCertSn,
			IssueCertSn:   revokeCertReq.IssueCertSn,
			Reason:        revokeCertReq.Reason,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}

		crlBytes = pem.EncodeToMemory(&pem.Block{Type: "CRL", Bytes: crlBytes})
		reCrlList := base64.StdEncoding.EncodeToString(crlBytes)
		SuccessfulJSONResp("", reCrlList, c)
	}
}

//Generate crl
func GenCrl() gin.HandlerFunc {
	return func(c *gin.Context) {
		var genCrlReq GenCrlReq
		if err := c.ShouldBind(&genCrlReq); err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		if genCrlReq.IssueCertSn == 0 {
			err := fmt.Errorf("input SN is illegal")
			InputErrorJSONResp(err.Error(), c)
			return
		}
		crlBytes, err := services.GenCrl(&services.GenCrlReq{
			IssueCertSn: genCrlReq.IssueCertSn,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}
		crlBytes = pem.EncodeToMemory(&pem.Block{Type: "CRL", Bytes: crlBytes})
		reCrlList := base64.StdEncoding.EncodeToString(crlBytes)
		SuccessfulJSONResp("", reCrlList, c)
	}
}

//generate csr
func GenCsr() gin.HandlerFunc {
	return func(c *gin.Context) {
		var genCsrReq GenCsrReq
		if err := c.ShouldBind(&genCsrReq); err != nil {
			InputErrorJSONResp(err.Error(), c)
			return
		}
		if err := services.CheckParametersEmpty(genCsrReq.OrgId, genCsrReq.UserId,
			genCsrReq.UserType, genCsrReq.PrivateKeyPwd,
			genCsrReq.Country, genCsrReq.Locality, genCsrReq.Province); err != nil {
			InputMissingJSONResp(err.Error(), c)
			return
		}
		curUserType, err := services.CheckParametersUserType(genCsrReq.UserType)
		if err != nil {
			InputMissingJSONResp(err.Error(), c)
			return
		}
		csrByte, err := services.GenCsr(&services.GenCsrReq{
			OrgId:         genCsrReq.OrgId,
			UserId:        genCsrReq.UserId,
			UserType:      curUserType,
			PrivateKeyPwd: genCsrReq.PrivateKeyPwd,
			Country:       genCsrReq.Country,
			Locality:      genCsrReq.Locality,
			Province:      genCsrReq.Province,
		})
		if err != nil {
			ServerErrorJSONResp(err.Error(), c)
			return
		}
		reCsr := base64.StdEncoding.EncodeToString(csrByte)
		SuccessfulJSONResp("", reCsr, c)
	}
}
